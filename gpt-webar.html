<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AR Experience â€” Image Tracking + Recording</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

    <!-- A-Frame + extras + MindAR -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

    <!-- Professional-Grade AR Smoothing (8th Wall-style approach) -->
    <script>
      // Multi-frame pose buffer for averaging (reduces single-frame jitter)
      class PoseBuffer {
        constructor(size = 5) {
          this.size = size;
          this.positions = [];
          this.quaternions = [];
        }
        add(pos, quat) {
          this.positions.push(pos.clone());
          this.quaternions.push(quat.clone());
          if (this.positions.length > this.size) {
            this.positions.shift();
            this.quaternions.shift();
          }
        }
        getAveraged() {
          if (this.positions.length === 0) return null;
          const avgPos = new THREE.Vector3();
          this.positions.forEach((p) => avgPos.add(p));
          avgPos.divideScalar(this.positions.length);
          const avgQuat = this.quaternions[0].clone();
          for (let i = 1; i < this.quaternions.length; i++) {
            avgQuat.slerp(this.quaternions[i], 1 / (i + 1));
          }
          return { position: avgPos, quaternion: avgQuat };
        }
        clear() { this.positions = []; this.quaternions = []; }
      }

      // Double Exponential Smoothing (like 8th Wall uses)
      class DoubleExpSmooth {
        constructor(alpha = 0.3, beta = 0.3) {
          this.alpha = alpha; this.beta = beta; this.level = null; this.trend = null;
        }
        update(value) {
          if (this.level === null) { this.level = value.clone(); this.trend = new THREE.Vector3(); return this.level.clone(); }
          const prevLevel = this.level.clone();
          this.level.lerp(value, this.alpha);
          const newTrend = this.level.clone().sub(prevLevel);
          this.trend.lerp(newTrend, this.beta);
          return this.level.clone().add(this.trend);
        }
        reset() { this.level = null; this.trend = null; }
      }

      // Professional AR Smoothing Component (8th Wall-inspired)
      AFRAME.registerComponent("pro-smooth", {
        schema: { posAlpha: {type: "number", default: 0.35}, rotAlpha: {type: "number", default: 0.35}, bufferSize: {type: "number", default: 4}, velocityThreshold: {type: "number", default: 0.5} },
        init: function () {
          this.poseBuffer = new PoseBuffer(this.data.bufferSize);
          this.posSmooth = new DoubleExpSmooth(this.data.posAlpha, this.data.posAlpha * 0.7);
          this.smoothPos = new THREE.Vector3(); this.smoothQuat = new THREE.Quaternion();
          this.prevPos = new THREE.Vector3(); this.velocity = new THREE.Vector3(); this.acceleration = new THREE.Vector3(); this.prevVelocity = new THREE.Vector3();
          this.firstUpdate = true; this.frameCount = 0; this.targetVisible = false;
          this.el.addEventListener("targetFound", () => { this.poseBuffer.clear(); this.posSmooth.reset(); this.firstUpdate = true; this.frameCount = 0; this.targetVisible = true; });
          this.el.addEventListener("targetLost",  () => { this.targetVisible = false; });
        },
        tick: function (time, deltaTime) {
          if (!this.targetVisible) return;
          const obj3D = this.el.object3D; const dt = Math.max(0.001, deltaTime / 1000);
          const rawPos = obj3D.position.clone(); const rawQuat = obj3D.quaternion.clone();
          this.velocity.copy(rawPos).sub(this.prevPos).divideScalar(dt);
          this.acceleration.copy(this.velocity).sub(this.prevVelocity).divideScalar(dt);
          const speed = this.velocity.length(); const accel = this.acceleration.length();
          this.poseBuffer.add(rawPos, rawQuat);
          const averaged = this.poseBuffer.getAveraged(); if (!averaged) return;
          if (this.firstUpdate || this.frameCount < 5) {
            this.smoothPos.copy(averaged.position); this.smoothQuat.copy(averaged.quaternion);
            this.firstUpdate = false; this.frameCount++;
          } else {
            const predicted = this.posSmooth.update(averaged.position);
            const velocityFactor = Math.min(speed * 0.15, 0.3);
            const accelFactor = Math.min(accel * 0.05, 0.2);
            const adaptiveAlpha = Math.min(this.data.posAlpha + velocityFactor + accelFactor, 0.7);
            this.smoothPos.lerp(predicted, adaptiveAlpha);
            const rotAlpha = Math.min(this.data.rotAlpha + speed * 0.12 + accel * 0.04, 0.6);
            this.smoothQuat.slerp(averaged.quaternion, rotAlpha);
          }
          obj3D.position.copy(this.smoothPos); obj3D.quaternion.copy(this.smoothQuat);
          this.prevPos.copy(rawPos); this.prevVelocity.copy(this.velocity);
        },
      });

      // Video fade & per-target play/pause
      AFRAME.registerComponent("target-video-fade", {
        schema: { video: { type: "selector" }, fadeDuration: { type: "number", default: 800 } },
        init: function () {
          this.video = this.data.video; this.material = null; this.fading = false; this.targetOpacity = 0; this.currentOpacity = 0;
          setTimeout(() => {
            const videoPlane = this.el.querySelector("a-video");
            if (videoPlane) {
              this.material = videoPlane.getObject3D("mesh").material;
              this.material.transparent = true; this.material.opacity = 0;
            }
          }, 100);
          this.el.addEventListener("targetFound", () => {
            if (this.video && this.video.paused) { this.video.play().catch(()=>{}); }
            this.targetOpacity = 1; this.fading = true;
          });
          this.el.addEventListener("targetLost", () => {
            this.targetOpacity = 0; this.fading = true;
            if (this.video) { this.video.pause(); }
          });
        },
        tick: function (time, deltaTime) {
          if (!this.material || !this.fading) return;
          const step = deltaTime / this.data.fadeDuration;
          if (this.targetOpacity > this.currentOpacity) this.currentOpacity = Math.min(this.currentOpacity + step, 1);
          else this.currentOpacity = Math.max(this.currentOpacity - step, 0);
          this.material.opacity = this.currentOpacity;
          if (Math.abs(this.currentOpacity - this.targetOpacity) < 0.01) { this.currentOpacity = this.targetOpacity; this.fading = false; }
        },
      });
    </script>

    <style>
      * { box-sizing: border-box; }
      html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; position: fixed; overscroll-behavior: none; -webkit-overflow-scrolling: touch; font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,sans-serif; }
      #start-overlay { position: fixed; inset: 0; background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); color:#fff; z-index:999; display:flex; flex-direction:column; justify-content:center; align-items:center; transition: opacity .3s ease; }
      #start-overlay.fade-out { opacity:0; pointer-events:none; }
      #start-overlay h1 { font-size:28px; margin-bottom:12px; text-align:center; padding:0 20px; }
      #start-overlay p { font-size:16px; opacity:.9; text-align:center; max-width:400px; padding:0 20px; margin-bottom:24px; }
      #start-button { padding:16px 48px; font-size:18px; font-weight:600; background:#fff; color:#667eea; border:0; border-radius:50px; cursor:pointer; box-shadow:0 4px 15px rgba(0,0,0,.2); transition: transform .2s, box-shadow .2s; }
      #start-button:hover { transform: translateY(-2px); box-shadow:0 6px 20px rgba(0,0,0,.3); }
      #start-button:active { transform: translateY(0); }
      #loading-indicator { position:fixed; top:20px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.75); color:#fff; padding:12px 24px; border-radius:25px; z-index:998; display:none; align-items:center; gap:12px; backdrop-filter: blur(10px); }
      #loading-indicator.show { display:flex; }
      .spinner { width:20px; height:20px; border:3px solid rgba(255,255,255,.3); border-top-color:#fff; border-radius:50%; animation: spin .8s linear infinite; }
      @keyframes spin { to { transform: rotate(360deg); } }
      #tracking-status { position:fixed; top:20px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.75); color:#fff; padding:12px 24px; border-radius:25px; z-index:997; display:none; align-items:center; gap:10px; backdrop-filter: blur(10px); transition: all .3s ease; }
      #tracking-status.show { display:flex; }
      #tracking-status.tracking { background: rgba(16,185,129,.9); }
      #tracking-status.searching { background: rgba(245,158,11,.9); }
      .status-dot { width:10px; height:10px; border-radius:50%; background:#fff; }
      .status-dot.pulse { animation: pulse 1.5s ease-in-out infinite; }
      @keyframes pulse { 0%,100%{opacity:1;transform:scale(1)} 50%{opacity:.5;transform:scale(.8)} }
      #instructions { position:fixed; bottom:100px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.75); color:#fff; padding:16px 24px; border-radius:20px; z-index:996; text-align:center; max-width:90%; backdrop-filter: blur(10px); display:none; animation: slideUp .5s ease; }
      #instructions.show { display:block; }
      @keyframes slideUp { from{transform:translate(-50%,20px); opacity:0} to{transform:translate(-50%,0); opacity:1} }
      #rec-controls { position:fixed !important; bottom:40px !important; left:50% !important; transform:translateX(-50%) !important; z-index:9999 !important; display:flex; flex-direction:column; align-items:center; gap:20px; pointer-events:auto; margin:0; padding:0; }
      #rec-status { display:flex; align-items:center; gap:12px; background:rgba(0,0,0,.75); padding:10px 20px; border-radius:25px; backdrop-filter: blur(10px); opacity:0; transition: opacity .3s ease; }
      #rec-status.show { opacity:1; }
      .rec-indicator { width:12px; height:12px; background:#ef4444; border-radius:50%; animation: recordingPulse 1.5s ease-in-out infinite; }
      @keyframes recordingPulse { 0%,100%{opacity:1;transform:scale(1)} 50%{opacity:.5;transform:scale(.8)} }
      #rec-duration { font-size:18px; font-weight:600; color:#fff; min-width:50px; font-variant-numeric: tabular-nums; }
      #capture-btn { width:70px; height:70px; min-width:70px; min-height:70px; max-width:70px; max-height:70px; aspect-ratio:1; border-radius:50%; background:#fff; border:5px solid rgba(255,255,255,.3); cursor:pointer; position:relative; transition: all .2s ease; display:flex; align-items:center; justify-content:center; box-shadow:0 4px 20px rgba(0,0,0,.3); pointer-events:auto; -webkit-tap-highlight-color:transparent; flex-shrink:0; }
      #capture-btn:hover { transform: scale(1.05); }
      #capture-btn:active { transform: scale(.95); }
      .capture-inner { width:56px; height:56px; min-width:56px; min-height:56px; max-width:56px; max-height:56px; aspect-ratio:1; background:#ef4444; border-radius:50%; transition: all .3s ease; flex-shrink:0; }
      #capture-btn.recording .capture-inner { width:28px; height:28px; min-width:28px; min-height:28px; max-width:28px; max-height:28px; border-radius:6px; }
      #dl { display:none; }
      #countdown-overlay { position:fixed; inset:0; background:rgba(0,0,0,.7); z-index:10000; display:none; justify-content:center; align-items:center; backdrop-filter: blur(5px); }
      #countdown-overlay.show { display:flex; }
      #countdown-number { font-size:120px; font-weight:700; color:#fff; animation: countdownScale 1s ease-in-out; }
      @keyframes countdownScale { 0%{transform:scale(.5);opacity:0} 50%{transform:scale(1.2);opacity:1} 100%{transform:scale(1);opacity:1} }
      @media (max-width: 600px) { #start-overlay h1{font-size:24px} #start-overlay p{font-size:14px} #start-button{padding:14px 36px;font-size:16px} #rec-controls{bottom:30px !important} #capture-btn{width:70px;height:70px;min-width:70px;min-height:70px;max-width:70px;max-height:70px} .capture-inner{width:56px;height:56px;min-width:56px;min-height:56px;max-width:56px;max-height:56px} #capture-btn.recording .capture-inner{width:28px;height:28px;min-width:28px;min-height:28px;max-width:28px;max-height:28px} #instructions{font-size:14px;bottom:120px} }
      #mix-canvas { display:none; }
      a-scene { position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; z-index:1 !important; overflow:hidden !important; }
      a-scene canvas { object-fit: cover !important; }
      #loading-indicator, #tracking-status, #instructions, #rec-controls, #countdown-overlay { pointer-events: auto; }
      body > * { max-height: 100vh; overflow: hidden; }
    </style>
  </head>

  <body>
    <!-- Start Overlay -->
    <div id="start-overlay">
      <h1>ðŸŽ¯ AR Image Tracking Experience</h1>
      <p>Point your camera at the target image to see AR content come to life!</p>
      <button id="start-button">Start Experience</button>
    </div>

    <!-- Loading Indicator -->
    <div id="loading-indicator"><div class="spinner"></div><span>Initializing AR...</span></div>

    <!-- Tracking Status -->
    <div id="tracking-status"><div class="status-dot"></div><span id="status-text">Searching for target...</span></div>

    <!-- Instructions -->
    <div id="instructions"><strong>ðŸ“± Point your camera at the target image</strong><br />Move slowly and keep the target in view</div>

    <!-- Camera-Style Recording Controls -->
    <div id="rec-controls">
      <div id="rec-status"><div class="rec-indicator"></div><span id="rec-duration">0:00</span></div>
      <button id="capture-btn"><div class="capture-inner"></div></button>
    </div>

    <!-- Countdown Overlay -->
    <div id="countdown-overlay"><div id="countdown-number">3</div></div>

    <!-- Hidden mixer canvas -->
    <canvas id="mix-canvas"></canvas>

    <!-- A-Frame Scene -->
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: false; uiScanning: auto; uiLoading: auto; filterMinCF:0.0005; filterBeta:2000; warmupTolerance:4; missTolerance:4"
      embedded
      color-space="sRGB"
      renderer="colorManagement: true, physicallyCorrectLights: true, antialias: true, precision: highp, logarithmicDepthBuffer: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: true"
      id="ar-scene"
    >
      <a-assets>
        <!-- One video per target image -->
        <video id="ad-video-0" src="./overlay2.mp4" preload="auto" crossorigin="anonymous" playsinline webkit-playsinline loop></video>
        <video id="ad-video-1" src="./overlay.mp4" preload="auto" crossorigin="anonymous" playsinline webkit-playsinline loop></video>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- Entity bound to image target index 0 -->
      <a-entity mindar-image-target="targetIndex: 0" id="target-0"
        pro-smooth="posAlpha: 0.35; rotAlpha: 0.35; bufferSize: 4"
        target-video-fade="video: #ad-video-0; fadeDuration: 600">
        <a-video src="#ad-video-0" width="1.02" height="1.53" position="0 0 0" rotation="0 0 0" material="shader: flat"></a-video>
      </a-entity>

      <!-- Entity bound to image target index 1 -->
      <a-entity mindar-image-target="targetIndex: 1" id="target-1"
        pro-smooth="posAlpha: 0.35; rotAlpha: 0.35; bufferSize: 4"
        target-video-fade="video: #ad-video-1; fadeDuration: 600">
        <a-video src="#ad-video-1" width="1.02" height="1.53" position="0 0 0" rotation="0 0 0" material="shader: flat"></a-video>
      </a-entity>
    </a-scene>

    <script>
      // ==================== State Management ====================
      const state = { audioUnlocked:false, arReady:false, cameraReady:false, recording:false, targetVisible:false, recordingStartTime:0 };

      // ==================== DOM Elements ====================
      const elements = {
        startButton: document.getElementById("start-button"),
        startOverlay: document.getElementById("start-overlay"),
        loadingIndicator: document.getElementById("loading-indicator"),
        trackingStatus: document.getElementById("tracking-status"),
        statusText: document.getElementById("status-text"),
        statusDot: document.querySelector(".status-dot"),
        instructions: document.getElementById("instructions"),
        captureBtn: document.getElementById("capture-btn"),
        recStatus: document.getElementById("rec-status"),
        recDuration: document.getElementById("rec-duration"),
        countdownOverlay: document.getElementById("countdown-overlay"),
        countdownNumber: document.getElementById("countdown-number"),
        sceneEl: document.getElementById("ar-scene"),
        mixCanvas: document.getElementById("mix-canvas"),
        overlayVideos: [],   // all <video> in <a-assets>
        targets: []          // all [mindar-image-target] entities
      };

      // ==================== Recording Variables ====================
      let mixCtx, rafId;
      let cameraVideoEl = null;
      let mediaRecorder, chunks = [];
      let audioCtx, dest, micStream = null;
      let durationInterval = null;
      const mediaElementSourceMap = new WeakMap(); // cache sources per video

      // ==================== UI Helpers ====================
      function showLoading(text = "Initializing AR...") {
        elements.loadingIndicator.querySelector("span").textContent = text;
        elements.loadingIndicator.classList.add("show");
      }
      function hideLoading() { elements.loadingIndicator.classList.remove("show"); }
      function updateTrackingStatus(isTracking) {
        state.targetVisible = isTracking;
        if (isTracking) {
          elements.trackingStatus.classList.add("tracking");
          elements.trackingStatus.classList.remove("searching");
          elements.statusText.textContent = "Target Locked âœ“";
          elements.statusDot.classList.remove("pulse");
          elements.instructions.classList.remove("show");
        } else {
          elements.trackingStatus.classList.remove("tracking");
          elements.trackingStatus.classList.add("searching");
          elements.statusText.textContent = "Searching for target...";
          elements.statusDot.classList.add("pulse");
          if (state.arReady) elements.instructions.classList.add("show");
        }
      }
      function formatDuration(seconds) { const mins = Math.floor(seconds/60); const secs = seconds%60; return `${mins}:${secs.toString().padStart(2,"0")}`; }
      function updateRecordingDuration() {
        if (state.recording) {
          const elapsed = Math.floor((Date.now() - state.recordingStartTime) / 1000);
          elements.recDuration.textContent = formatDuration(elapsed);
        }
      }
      async function showCountdown() {
        elements.countdownOverlay.classList.add("show");
        for (let i = 3; i > 0; i--) {
          elements.countdownNumber.textContent = i;
          elements.countdownNumber.style.animation = "none"; void elements.countdownNumber.offsetWidth;
          elements.countdownNumber.style.animation = "countdownScale 1s ease-in-out";
          await new Promise((r)=>setTimeout(r,1000));
        }
        elements.countdownOverlay.classList.remove("show");
      }

      // ==================== Start Experience ====================
      elements.startButton.addEventListener("click", async () => {
        try {
          showLoading("Unlocking media...");

          // collect all overlay videos and unlock audio on each
          elements.overlayVideos = Array.from(document.querySelectorAll('a-assets > video'));
          for (const v of elements.overlayVideos) { try { await v.play(); v.pause(); } catch(_) {} }
          state.audioUnlocked = true;

          // Hide start overlay
          elements.startOverlay.classList.add("fade-out");
          setTimeout(()=>{ elements.startOverlay.style.display="none"; }, 300);

          showLoading("Starting AR tracking...");

          // Start MindAR
          const arSystem = elements.sceneEl.systems["mindar-image-system"];
          await arSystem.start();
        } catch (e) {
          console.error("Start failed:", e);
          alert("Failed to start AR. Please refresh and try again.");
          hideLoading();
        }
      });

      // ==================== AR Event Handlers ====================
      elements.sceneEl.addEventListener("arReady", () => {
        console.log("AR System Ready");
        state.arReady = true; hideLoading();

        elements.trackingStatus.classList.add("show");
        updateTrackingStatus(false);
        elements.instructions.classList.add("show");

        // collect targets and listen for found/lost
        elements.targets = Array.from(document.querySelectorAll('[mindar-image-target]'));
        let visibleCount = 0;
        elements.targets.forEach((t) => {
          t.addEventListener("targetFound", () => { visibleCount++; updateTrackingStatus(true); });
          t.addEventListener("targetLost",  () => { visibleCount = Math.max(0, visibleCount-1); updateTrackingStatus(visibleCount > 0); });
        });

        // Find the camera <video> element (the one with a MediaStream)
        setTimeout(() => {
          const vids = Array.from(document.querySelectorAll("video"));
          cameraVideoEl = vids.find((v) => v.srcObject instanceof MediaStream);
          if (cameraVideoEl) {
            state.cameraReady = true;
            const settings = cameraVideoEl.srcObject.getVideoTracks()[0]?.getSettings?.() || {};
            console.log("Camera ready:", settings.width, "x", settings.height, settings.frameRate || "fps?");
          } else {
            console.warn("Camera video element not found yet");
            setTimeout(() => {
              const retryVids = Array.from(document.querySelectorAll("video"));
              cameraVideoEl = retryVids.find((v)=> v.srcObject instanceof MediaStream);
              if (cameraVideoEl) state.cameraReady = true;
            }, 1000);
          }
        }, 500);
      });

      // ==================== Recording Functions ====================
      function pickMime() {
        const prefs = ["video/mp4;codecs=avc1.42E01E,mp4a.40.2","video/webm;codecs=vp9,opus","video/webm;codecs=vp8,opus","video/webm"];
        return (prefs.find((t) => window.MediaRecorder && MediaRecorder.isTypeSupported(t)) || "");
      }

      function sizeMixCanvas() {
        const camW = cameraVideoEl?.videoWidth || 0;
        const camH = cameraVideoEl?.videoHeight || 0;
        const sceneCanvas = elements.sceneEl?.canvas;
        const w = sceneCanvas?.width || camW || 1280;
        const h = sceneCanvas?.height || camH || 720;
        elements.mixCanvas.width = w; elements.mixCanvas.height = h;
        if (!mixCtx) mixCtx = elements.mixCanvas.getContext("2d", { alpha:false, desynchronized:true, willReadFrequently:false });
      }

      function drawComposite() {
        if (!state.recording) return;
        const sceneCanvas = elements.sceneEl.canvas;
        if (!cameraVideoEl || !sceneCanvas) { rafId = requestAnimationFrame(drawComposite); return; }
        try {
          const canvasW = elements.mixCanvas.width, canvasH = elements.mixCanvas.height;
          mixCtx.clearRect(0, 0, canvasW, canvasH);
          const camAspect = cameraVideoEl.videoWidth / cameraVideoEl.videoHeight;
          const canvasAspect = canvasW / canvasH;
          let drawW, drawH, offsetX = 0, offsetY = 0;
          if (camAspect > canvasAspect) { drawH = canvasH; drawW = drawH * camAspect; offsetX = (canvasW - drawW) / 2; }
          else { drawW = canvasW; drawH = drawW / camAspect; offsetY = (canvasH - drawH) / 2; }
          mixCtx.drawImage(cameraVideoEl, 0, 0, cameraVideoEl.videoWidth, cameraVideoEl.videoHeight, offsetX, offsetY, drawW, drawH);
          mixCtx.drawImage(sceneCanvas, 0, 0, sceneCanvas.width, sceneCanvas.height, 0, 0, canvasW, canvasH);
        } catch (e) { console.warn("Composite draw failed:", e); }
        rafId = requestAnimationFrame(drawComposite);
      }

      async function startCompositeRecording() {
        if (!state.cameraReady || !cameraVideoEl || !(cameraVideoEl.srcObject instanceof MediaStream)) { alert("Camera not ready yet. Try again."); return; }
        if (!elements.sceneEl.canvas) { alert("AR scene not ready. Try again."); return; }

        await showCountdown();
        sizeMixCanvas();
        cancelAnimationFrame(rafId);
        state.recording = true;
        drawComposite();

        const fps = 30;
        const captureStream = elements.mixCanvas.captureStream(fps);
        const videoTrack = captureStream.getVideoTracks()[0];

        // Setup audio mixing
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        dest = audioCtx.createMediaStreamDestination();

        // Route ALL overlay videos (reuse cached MediaElementSourceNodes safely)
        for (const v of elements.overlayVideos) {
          try {
            let src = mediaElementSourceMap.get(v);
            if (!src) { src = audioCtx.createMediaElementSource(v); mediaElementSourceMap.set(v, src); }
            // reset old connections (avoid stacking between recordings)
            try { src.disconnect(); } catch(_) {}
            src.connect(dest);
            src.connect(audioCtx.destination); // local monitor
          } catch (e) {
            console.warn("Audio routing issue for a video element:", e);
          }
        }

        // Mic (optional)
        try { micStream = await navigator.mediaDevices.getUserMedia({ audio: true }); audioCtx.createMediaStreamSource(micStream).connect(dest); }
        catch (e) { console.warn("Microphone access denied:", e); }

        const outStream = new MediaStream([ videoTrack, ...dest.stream.getAudioTracks() ]);
        const recordingOptions = { mimeType: pickMime(), videoBitsPerSecond: 8_000_000 };

        mediaRecorder = new MediaRecorder(outStream, recordingOptions);
        chunks = [];
        mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
        mediaRecorder.onstop = () => {
          const blob = new Blob(chunks, { type: mediaRecorder.mimeType || "video/webm" });
          const url = URL.createObjectURL(blob);
          const downloadLink = document.createElement("a");
          downloadLink.href = url;
          downloadLink.download = (mediaRecorder.mimeType || "").includes("mp4") ? "ar-recording.mp4" : "ar-recording.webm";
          document.body.appendChild(downloadLink); downloadLink.click(); document.body.removeChild(downloadLink);
          setTimeout(() => URL.revokeObjectURL(url), 100);

          cancelAnimationFrame(rafId);
          if (micStream) { micStream.getTracks().forEach((t)=>t.stop()); micStream = null; }
          try { audioCtx.close(); } catch(_) {}

          state.recording = false;
          elements.captureBtn.classList.remove("recording");
          elements.recStatus.classList.remove("show");
          clearInterval(durationInterval);
        };

        if (audioCtx.state === "suspended") await audioCtx.resume();
        mediaRecorder.start();
        state.recordingStartTime = Date.now();
        elements.captureBtn.classList.add("recording");
        elements.recStatus.classList.add("show");
        elements.recDuration.textContent = "0:00";
        durationInterval = setInterval(updateRecordingDuration, 1000);
      }

      function stopCompositeRecording() { if (mediaRecorder && state.recording) mediaRecorder.stop(); }

      // ==================== Event Listeners ====================
      elements.captureBtn.addEventListener("click", () => { if (!state.recording) startCompositeRecording(); else stopCompositeRecording(); });

      window.addEventListener("beforeunload", (e) => { if (state.recording) { e.preventDefault(); e.returnValue = ""; } });

      // ==================== Prevent Scrolling ====================
      window.addEventListener("scroll", (e) => { window.scrollTo(0,0); e.preventDefault(); }, { passive:false });
      document.body.addEventListener("touchmove", (e) => { if (!e.target.closest("#capture-btn, button, input")) e.preventDefault(); }, { passive:false });
      window.scrollTo(0,0); document.body.style.position="fixed"; document.body.style.width="100%"; document.body.style.height="100%";
    </script>
  </body>
</html>
